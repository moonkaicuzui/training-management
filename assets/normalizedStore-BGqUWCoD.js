import{a as D,r as B}from"./vendor-react-3RSvEdhP.js";import{q as v,r as I,s as F,t as O,v as z,w as T,x as j,y as C,z as N,A as L,E as U,F as G}from"./index-DbE0N-7e.js";const x=s=>Symbol.iterator in s,S=s=>"entries"in s,M=(s,a)=>{const e=s instanceof Map?s:new Map(s.entries()),t=a instanceof Map?a:new Map(a.entries());if(e.size!==t.size)return!1;for(const[r,n]of e)if(!t.has(r)||!Object.is(n,t.get(r)))return!1;return!0},k=(s,a)=>{const e=s[Symbol.iterator](),t=a[Symbol.iterator]();let r=e.next(),n=t.next();for(;!r.done&&!n.done;){if(!Object.is(r.value,n.value))return!1;r=e.next(),n=t.next()}return!!r.done&&!!n.done};function H(s,a){return Object.is(s,a)?!0:typeof s!="object"||s===null||typeof a!="object"||a===null||Object.getPrototypeOf(s)!==Object.getPrototypeOf(a)?!1:x(s)&&x(a)?S(s)&&S(a)?M(s,a):k(s,a):M({entries:()=>Object.entries(s)},{entries:()=>Object.entries(a)})}function q(s){const a=D.useRef(void 0);return e=>{const t=s(e);return H(a.current,t)?a.current:a.current=t}}const w=s=>s,P=s=>s,R=s=>s,W=s=>s,f=s=>s,_=s=>s,X=s=>s,A=s=>({...s,program_code:s.program_code,tags:Object.freeze([...s.tags]),target_positions:Object.freeze([...s.target_positions]),grade_thresholds:{aa:s.grade_aa,a:s.grade_a,b:s.grade_b},created_at:s.created_at,updated_at:s.updated_at}),J=s=>({employee_id:w(s.employee_id),employee_name:s.employee_name,department:s.department,position:s.position,building:s.building,line:s.line,hire_date:f(s.hire_date),status:s.status,updated_at:_(s.updated_at)}),K=s=>({session_id:R(s.session_id),program_code:P(s.program_code),session_date:f(s.session_date),session_time:X(s.session_time),trainer:{name:s.trainer_name||s.trainer,employee_id:void 0},location:s.location,max_attendees:s.max_attendees,attendees:Object.freeze(s.attendees.map(w)),status:s.status,notes:s.notes,created_by:s.created_by,created_at:_(s.created_at)}),Q=s=>({result_id:W(s.result_id),session_id:s.session_id?R(s.session_id):null,employee_id:w(s.employee_id),program_code:P(s.program_code),training_date:f(s.training_date),score:s.score,grade:s.grade,result:s.result,needs_retraining:s.needs_retraining,evaluated_by:s.evaluated_by,remarks:s.remarks,created_at:_(s.created_at),updated_at:s.updated_at?_(s.updated_at):null,updated_by:s.updated_by}),u=s=>s.map(J),m=s=>s.map(A),V=s=>s.map(K),b=s=>s.map(Q),E={entities:{employees:new Map,programs:new Map,sessions:new Map,results:new Map},indexes:{resultsByEmployee:new Map,resultsByProgram:new Map,sessionsByProgram:new Map,resultsBySession:new Map},ui:{selectedEmployeeId:null,selectedProgramCode:null,selectedSessionId:null},filters:{employees:{},programs:{},sessions:{},results:{},progressMatrix:{}},loading:{entities:{employees:!1,programs:!1,sessions:!1,results:!1},views:{dashboard:!1,progressMatrix:!1,retraining:!1}},derived:{dashboard:{stats:null,monthlyData:[],gradeDistribution:[]},progressMatrix:null,retraining:{targets:[],expiring:[]}}},y=v()(I((s,a)=>({...E,fetchEmployees:async e=>{s(t=>({loading:{...t.loading,entities:{...t.loading.entities,employees:!0}}}));try{const t=e?{department:e.department,position:e.position,building:e.building,line:e.line,status:e.status,search:e.search}:{},r=await G(t),n=u(r),o=new Map;n.forEach(i=>o.set(i.employee_id,i)),s(i=>({entities:{...i.entities,employees:o},filters:{...i.filters,employees:e||{}}}))}catch(t){throw console.error("Failed to fetch employees:",t),t}finally{s(t=>({loading:{...t.loading,entities:{...t.loading.entities,employees:!1}}}))}},getEmployee:e=>a().entities.employees.get(e),setSelectedEmployee:e=>{s(t=>({ui:{...t.ui,selectedEmployeeId:e}}))},addEmployee:e=>{s(t=>{const r=new Map(t.entities.employees);return r.set(e.employee_id,e),{entities:{...t.entities,employees:r}}})},updateEmployee:(e,t)=>{s(r=>{const n=r.entities.employees.get(e);if(!n)return r;const o={...n,...t},i=new Map(r.entities.employees);return i.set(e,o),{entities:{...r.entities,employees:i}}})},fetchPrograms:async e=>{s(t=>({loading:{...t.loading,entities:{...t.loading.entities,programs:!0}}}));try{const t=e?{category:e.category,showInactive:e.showInactive,search:e.search,tags:e.tags?[...e.tags]:void 0}:{},r=await U(t),n=m(r),o=new Map;n.forEach(i=>o.set(i.program_code,i)),s(i=>({entities:{...i.entities,programs:o},filters:{...i.filters,programs:e||{}}}))}catch(t){throw console.error("Failed to fetch programs:",t),t}finally{s(t=>({loading:{...t.loading,entities:{...t.loading.entities,programs:!1}}}))}},getProgram:e=>a().entities.programs.get(e),setSelectedProgram:e=>{s(t=>({ui:{...t.ui,selectedProgramCode:e}}))},addProgram:e=>{s(t=>{const r=new Map(t.entities.programs);return r.set(e.program_code,e),{entities:{...t.entities,programs:r}}})},updateProgram:(e,t)=>{s(r=>{const n=r.entities.programs.get(e);if(!n)return r;const o={...n,...t},i=new Map(r.entities.programs);return i.set(e,o),{entities:{...r.entities,programs:i}}})},deactivateProgram:e=>{a().updateProgram(e,{is_active:!1})},fetchSessions:async e=>{s(t=>({loading:{...t.loading,entities:{...t.loading.entities,sessions:!0}}}));try{const t=e?{startDate:e.startDate,endDate:e.endDate,programCode:e.programCode,status:e.status}:{},r=await L(t),n=V(r),o=new Map,i=new Map;n.forEach(c=>{o.set(c.session_id,c);const l=i.get(c.program_code)||new Set;l.add(c.session_id),i.set(c.program_code,l)}),s(c=>({entities:{...c.entities,sessions:o},indexes:{...c.indexes,sessionsByProgram:i},filters:{...c.filters,sessions:e||{}}}))}catch(t){throw console.error("Failed to fetch sessions:",t),t}finally{s(t=>({loading:{...t.loading,entities:{...t.loading.entities,sessions:!1}}}))}},getSession:e=>a().entities.sessions.get(e),setSelectedSession:e=>{s(t=>({ui:{...t.ui,selectedSessionId:e}}))},addSession:e=>{s(t=>{const r=new Map(t.entities.sessions);r.set(e.session_id,e);const n=new Map(t.indexes.sessionsByProgram),o=n.get(e.program_code)||new Set;return o.add(e.session_id),n.set(e.program_code,o),{entities:{...t.entities,sessions:r},indexes:{...t.indexes,sessionsByProgram:n}}})},updateSession:(e,t)=>{s(r=>{const n=r.entities.sessions.get(e);if(!n)return r;const o={...n,...t},i=new Map(r.entities.sessions);return i.set(e,o),{entities:{...r.entities,sessions:i}}})},cancelSession:e=>{a().updateSession(e,{status:"CANCELLED"})},fetchResults:async e=>{s(t=>({loading:{...t.loading,entities:{...t.loading.entities,results:!0}}}));try{const t=e?{employeeId:e.employeeId,programCode:e.programCode,startDate:e.startDate,endDate:e.endDate,result:e.result,grade:e.grade}:{},r=await N(t),n=b(r),o=new Map,i=new Map,c=new Map,l=new Map;n.forEach(d=>{o.set(d.result_id,d);const g=i.get(d.employee_id)||new Set;g.add(d.result_id),i.set(d.employee_id,g);const p=c.get(d.program_code)||new Set;if(p.add(d.result_id),c.set(d.program_code,p),d.session_id){const h=l.get(d.session_id)||new Set;h.add(d.result_id),l.set(d.session_id,h)}}),s(d=>({entities:{...d.entities,results:o},indexes:{...d.indexes,resultsByEmployee:i,resultsByProgram:c,resultsBySession:l},filters:{...d.filters,results:e||{}}}))}catch(t){throw console.error("Failed to fetch results:",t),t}finally{s(t=>({loading:{...t.loading,entities:{...t.loading.entities,results:!1}}}))}},getResult:e=>a().entities.results.get(e),addResult:e=>{s(t=>{const r=new Map(t.entities.results);r.set(e.result_id,e);const n={...t.indexes},o=n.resultsByEmployee.get(e.employee_id)||new Set;o.add(e.result_id),n.resultsByEmployee=new Map(n.resultsByEmployee),n.resultsByEmployee.set(e.employee_id,o);const i=n.resultsByProgram.get(e.program_code)||new Set;if(i.add(e.result_id),n.resultsByProgram=new Map(n.resultsByProgram),n.resultsByProgram.set(e.program_code,i),e.session_id){const c=n.resultsBySession.get(e.session_id)||new Set;c.add(e.result_id),n.resultsBySession=new Map(n.resultsBySession),n.resultsBySession.set(e.session_id,c)}return{entities:{...t.entities,results:r},indexes:n}})},updateResult:(e,t)=>{s(r=>{const n=r.entities.results.get(e);if(!n)return r;const o={...n,...t},i=new Map(r.entities.results);return i.set(e,o),{entities:{...r.entities,results:i}}})},getEmployeeHistory:e=>{const t=a().indexes.resultsByEmployee.get(e)||new Set,r=[];return t.forEach(n=>{const o=a().entities.results.get(n);o&&r.push(o)}),r.sort((n,o)=>o.training_date.localeCompare(n.training_date))},getProgramResults:e=>{const t=a().indexes.resultsByProgram.get(e)||new Set,r=[];return t.forEach(n=>{const o=a().entities.results.get(n);o&&r.push(o)}),r.sort((n,o)=>o.training_date.localeCompare(n.training_date))},getSessionResults:e=>{const t=a().indexes.resultsBySession.get(e)||new Set,r=[];return t.forEach(n=>{const o=a().entities.results.get(n);o&&r.push(o)}),r},getProgramSessions:e=>{const t=a().indexes.sessionsByProgram.get(e)||new Set,r=[];return t.forEach(n=>{const o=a().entities.sessions.get(n);o&&r.push(o)}),r.sort((n,o)=>o.session_date.localeCompare(n.session_date))},setEmployeeFilters:e=>{s(t=>({filters:{...t.filters,employees:e}})),a().fetchEmployees(e)},setProgramFilters:e=>{s(t=>({filters:{...t.filters,programs:e}})),a().fetchPrograms(e)},setSessionFilters:e=>{s(t=>({filters:{...t.filters,sessions:e}})),a().fetchSessions(e)},setResultFilters:e=>{s(t=>({filters:{...t.filters,results:e}})),a().fetchResults(e)},setProgressFilters:e=>{s(t=>({filters:{...t.filters,progressMatrix:e}})),a().fetchProgressMatrix(e)},clearAllFilters:()=>{s({filters:{employees:{},programs:{},sessions:{},results:{},progressMatrix:{}}})},fetchDashboardStats:async()=>{s(e=>({loading:{...e.loading,views:{...e.loading.views,dashboard:!0}}}));try{const e=await C();s(t=>({derived:{...t.derived,dashboard:{...t.derived.dashboard,stats:e}}}))}catch(e){throw console.error("Failed to fetch dashboard stats:",e),e}finally{s(e=>({loading:{...e.loading,views:{...e.loading.views,dashboard:!1}}}))}},fetchMonthlyData:async()=>{try{const e=await j();s(t=>({derived:{...t.derived,dashboard:{...t.derived.dashboard,monthlyData:e}}}))}catch(e){throw console.error("Failed to fetch monthly data:",e),e}},fetchGradeDistribution:async()=>{try{const e=await T();s(t=>({derived:{...t.derived,dashboard:{...t.derived.dashboard,gradeDistribution:e}}}))}catch(e){throw console.error("Failed to fetch grade distribution:",e),e}},fetchProgressMatrix:async e=>{s(t=>({loading:{...t.loading,views:{...t.loading.views,progressMatrix:!0}}}));try{const t=e?{building:e.building,department:e.department,line:e.line,position:e.position,category:e.category}:{},r=await z(t),n=u(r.employees),o=m(r.programs),i={},c=[];for(const l of r.cells){const d=l.employeeId,g=l.programCode,p={employee_id:d,program_code:g,status:l.status,last_result:l.lastResult?.result||null,last_score:l.lastResult?.score||null,last_grade:l.lastResult?.grade||null,last_training_date:l.lastResult?.training_date||null,expiration_date:l.expirationDate||null,days_until_expiry:l.expirationDate?Math.ceil((new Date(l.expirationDate).getTime()-Date.now())/(1e3*60*60*24)):null,completion_count:1};c.push(p),i[d]||(i[d]={}),i[d][g]=p}s(l=>({derived:{...l.derived,progressMatrix:{employees:Object.freeze(n),programs:Object.freeze(o),cells:Object.freeze(c),matrix:Object.freeze(i)}},filters:{...l.filters,progressMatrix:e||{}}}))}catch(t){throw console.error("Failed to fetch progress matrix:",t),t}finally{s(t=>({loading:{...t.loading,views:{...t.loading.views,progressMatrix:!1}}}))}},fetchRetrainingTargets:async()=>{s(e=>({loading:{...e.loading,views:{...e.loading.views,retraining:!0}}}));try{const t=(await O()).map(r=>({employee:u([r.employee])[0],program:m([r.program])[0],last_result:b([r.lastResult])[0],reason:r.reason,priority:r.reason==="FAILED"?"HIGH":r.reason==="EXPIRED"?"MEDIUM":"LOW",recommended_programs:r.recommendedPrograms?Object.freeze(m(r.recommendedPrograms)):void 0}));s(r=>({derived:{...r.derived,retraining:{...r.derived.retraining,targets:t}}}))}catch(e){throw console.error("Failed to fetch retraining targets:",e),e}finally{s(e=>({loading:{...e.loading,views:{...e.loading.views,retraining:!1}}}))}},fetchExpiringTrainings:async(e=30)=>{try{const r=(await F(e)).map(n=>({employee:u([n.employee])[0],program:m([n.program])[0],last_pass_date:n.lastPassDate,expiration_date:n.expirationDate,days_until_expiry:n.daysUntilExpiry,priority:n.daysUntilExpiry<=7?"URGENT":n.daysUntilExpiry<=14?"SOON":"NORMAL"}));s(n=>({derived:{...n.derived,retraining:{...n.derived.retraining,expiring:r}}}))}catch(t){throw console.error("Failed to fetch expiring trainings:",t),t}},rebuildIndexes:()=>{s(e=>{const t={resultsByEmployee:new Map,resultsByProgram:new Map,sessionsByProgram:new Map,resultsBySession:new Map};return e.entities.results.forEach(r=>{const n=t.resultsByEmployee.get(r.employee_id)||new Set;n.add(r.result_id),t.resultsByEmployee.set(r.employee_id,n);const o=t.resultsByProgram.get(r.program_code)||new Set;if(o.add(r.result_id),t.resultsByProgram.set(r.program_code,o),r.session_id){const i=t.resultsBySession.get(r.session_id)||new Set;i.add(r.result_id),t.resultsBySession.set(r.session_id,i)}}),e.entities.sessions.forEach(r=>{const n=t.sessionsByProgram.get(r.program_code)||new Set;n.add(r.session_id),t.sessionsByProgram.set(r.program_code,n)}),{indexes:t}})},clearAllData:()=>{s(E)}}),{name:"NormalizedTrainingStore"})),$=()=>{const s=y(r=>r.entities.employees),a=y(r=>r.loading.entities.employees),e=y(r=>r.filters.employees);return{employees:B.useMemo(()=>Array.from(s.values()),[s]),loading:a,filters:e}},ee=()=>y(q(s=>({progressMatrix:s.derived.progressMatrix,loading:s.loading.views.progressMatrix,filters:s.filters.progressMatrix})));export{ee as a,$ as b,y as u};
